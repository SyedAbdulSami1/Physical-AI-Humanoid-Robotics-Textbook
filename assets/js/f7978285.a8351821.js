"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[1105],{2476:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2/simulating-physics-in-gazebo","title":"The Digital Twin: Simulating Physics in Gazebo","description":"Welcome to the world of the digital twin, where we forge a virtual copy of our robot to test, train, and iterate without risking physical hardware. Our primary tool for this is Gazebo, a powerful 3D robotics simulator that allows us to model not just the robot, but the world it lives in\u2014complete with gravity, friction, and collisions.","source":"@site/docs/module-2/simulating-physics-in-gazebo.md","sourceDirName":"module-2","slug":"/module-2/simulating-physics-in-gazebo","permalink":"/docs/module-2/simulating-physics-in-gazebo","draft":false,"unlisted":false,"editUrl":"https://github.com/SyedAbdulSami1/Physical-AI-Humanoid-Robotics-Textbook/tree/main/docs/module-2/simulating-physics-in-gazebo.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: The Digital Twin (Gazebo & Unity)","permalink":"/docs/category/module-2-the-digital-twin-gazebo--unity"},"next":{"title":"High-Fidelity Rendering and Human-Robot Interaction in Unity","permalink":"/docs/module-2/high-fidelity-rendering-in-unity"}}');var s=i(4848),r=i(8453);const t={sidebar_position:1},l="The Digital Twin: Simulating Physics in Gazebo",a={},c=[{value:"Gazebo and ROS 2: A Symbiotic Relationship",id:"gazebo-and-ros-2-a-symbiotic-relationship",level:2},{value:"SDF: The Language of Simulation",id:"sdf-the-language-of-simulation",level:2},{value:"Lab 1: Creating a Basic Gazebo World",id:"lab-1-creating-a-basic-gazebo-world",level:2},{value:"Step 1: Create a World File",id:"step-1-create-a-world-file",level:3},{value:"Step 2: Create a Launch File for the World",id:"step-2-create-a-launch-file-for-the-world",level:3},{value:"Step 3: Build and Launch",id:"step-3-build-and-launch",level:3},{value:"Lab 2: Spawning Your Humanoid in Gazebo",id:"lab-2-spawning-your-humanoid-in-gazebo",level:2},{value:"Step 1: Add a Gazebo Plugin to your URDF",id:"step-1-add-a-gazebo-plugin-to-your-urdf",level:3},{value:"Step 2: Create a Launch File to Spawn the Robot",id:"step-2-create-a-launch-file-to-spawn-the-robot",level:3},{value:"Step 3: Build and Launch",id:"step-3-build-and-launch-1",level:3},{value:"Common Errors and Debugging",id:"common-errors-and-debugging",level:2},{value:"Student Exercises",id:"student-exercises",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"the-digital-twin-simulating-physics-in-gazebo",children:"The Digital Twin: Simulating Physics in Gazebo"})}),"\n",(0,s.jsxs)(n.p,{children:["Welcome to the world of the digital twin, where we forge a virtual copy of our robot to test, train, and iterate without risking physical hardware. Our primary tool for this is ",(0,s.jsx)(n.strong,{children:"Gazebo"}),", a powerful 3D robotics simulator that allows us to model not just the robot, but the world it lives in\u2014complete with gravity, friction, and collisions."]}),"\n",(0,s.jsx)(n.p,{children:"Gazebo is more than just a visualizer; it's a physics engine. It understands how objects should interact, fall, and collide. By accurately simulating these physical laws, we can develop and validate our robot's control algorithms in a realistic, repeatable, and safe environment. This chapter will guide you through setting up a Gazebo world, importing your robot, and understanding the key physics properties that bring your simulation to life."}),"\n",(0,s.jsx)(n.h2,{id:"gazebo-and-ros-2-a-symbiotic-relationship",children:"Gazebo and ROS 2: A Symbiotic Relationship"}),"\n",(0,s.jsxs)(n.p,{children:["Gazebo is a standalone application, but its true power is unlocked when used with ROS 2. The ",(0,s.jsx)(n.code,{children:"gazebo_ros_pkgs"})," provide a bridge, allowing Gazebo to seamlessly integrate into the ROS 2 ecosystem."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo as a collection of ROS 2 Nodes"}),": The Gazebo server can be seen as a ROS 2 node that provides services to spawn and delete robot models."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plugins as ROS 2 Nodes"}),": Gazebo plugins (for sensors, controllers, etc.) can also be ROS 2 nodes, publishing data to topics (like ",(0,s.jsx)(n.code,{children:"/scan"})," or ",(0,s.jsx)(n.code,{children:"/camera/image_raw"}),") and offering services."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simulation Time"}),": Gazebo publishes the simulation time to the ",(0,s.jsx)(n.code,{children:"/clock"})," topic. ROS 2 nodes can be configured to use this simulation time, ensuring that all events are synchronized with the physics simulation, not the real world's clock."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'This integration allows us to run the exact same AI agent code in both the simulation and on the real robot, a cornerstone of the "sim-to-real" paradigm.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    subgraph Gazebo Simulation\n        A[Gazebo Server] -- Physics & World State --\x3e B(Gazebo Plugins);\n        B -- Sensor Data --\x3e C((ROS 2 Topics));\n        D((ROS 2 Services)) -- Spawn/Delete Models --\x3e A;\n    end\n    subgraph ROS 2 System\n        C -- Sensor Data --\x3e E[AI Agent Node];\n        E -- Control Commands --\x3e F((ROS 2 Topics));\n        F -- Control Commands --\x3e B;\n        E -- Calls Service --\x3e D;\n    end\n"})}),"\n",(0,s.jsx)(n.h2,{id:"sdf-the-language-of-simulation",children:"SDF: The Language of Simulation"}),"\n",(0,s.jsxs)(n.p,{children:["While URDF is excellent for describing a robot's kinematics, Gazebo uses a more comprehensive format called the ",(0,s.jsx)(n.strong,{children:"Simulation Description Format (SDF)"}),". SDF is a superset of URDF and can describe not only robots, but entire worlds\u2014including lighting, terrain, static objects, and physics properties."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key SDF Tags for Physics"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<world>"})}),": The top-level element that contains everything in the simulation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<physics>"})}),": Defines the global physics parameters.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"}),": The physics engine to use (e.g., ",(0,s.jsx)(n.code,{children:"ode"}),", ",(0,s.jsx)(n.code,{children:"bullet"}),", ",(0,s.jsx)(n.code,{children:"dart"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max_step_size"}),": The time increment for each physics update."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"real_time_factor"}),": A target for how fast the simulation should run relative to real time."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gravity"}),": The gravity vector (e.g., ",(0,s.jsx)(n.code,{children:"0 0 -9.8"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<collision>"})}),": (Inside a ",(0,s.jsx)(n.code,{children:"<link>"}),") Defines the shape for physics interactions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<surface>"})}),": (Inside a ",(0,s.jsx)(n.code,{children:"<collision>"}),") Defines the properties of the link's surface.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<friction>"})}),": Specifies static and dynamic friction coefficients."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<restitution>"})}),': Specifies the "bounciness" of the surface.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<contact>"})}),": Defines properties like stiffness and damping for when objects touch."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately, you don't have to throw away your URDF. Gazebo provides tools to automatically convert a URDF into an SDF file. However, to add Gazebo-specific tags (like materials, plugins, and detailed physics), we use ",(0,s.jsx)(n.code,{children:"<gazebo>"})," extension tags directly within our URDF/XACRO files."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Adding Gazebo friction to a URDF link:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<link name="wheel">\n  \x3c!-- ... visual, inertial, collision ... --\x3e\n</link>\n\n<gazebo reference="wheel">\n  <mu1>1.0</mu1> \x3c!-- Static friction coefficient --\x3e\n  <mu2>0.9</mu2> \x3c!-- Dynamic friction coefficient --\x3e\n  <material>Gazebo/Grey</material>\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lab-1-creating-a-basic-gazebo-world",children:"Lab 1: Creating a Basic Gazebo World"}),"\n",(0,s.jsx)(n.p,{children:"Let's build a simple world file with a ground plane and a few obstacles."}),"\n",(0,s.jsx)(n.h3,{id:"step-1-create-a-world-file",children:"Step 1: Create a World File"}),"\n",(0,s.jsxs)(n.p,{children:["In your ",(0,s.jsx)(n.code,{children:"humanoid_description"})," package, create a ",(0,s.jsx)(n.code,{children:"worlds"})," directory. Inside, create ",(0,s.jsx)(n.code,{children:"obstacle_course.world"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File"}),": ",(0,s.jsx)(n.code,{children:"humanoid_description/worlds/obstacle_course.world"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="default">\n    \x3c!-- A global light source --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- A ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Define the physics engine --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- A simple box obstacle --\x3e\n    <model name="box_obstacle_1">\n      <pose>2.0 1.0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box><size>1 1 1</size></box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box><size>1 1 1</size></box>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- A cylinder obstacle --\x3e\n    <model name="cylinder_obstacle_1">\n      <pose>-1.5 -2.0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <cylinder><radius>0.5</radius><length>1.0</length></cylinder>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <cylinder><radius>0.5</radius><length>1.0</length></cylinder>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Image: A simple Gazebo world with two obstacles."}),"\n",(0,s.jsx)(n.em,{children:"A screenshot showing a ground plane with a box and a cylinder obstacle."})]})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-a-launch-file-for-the-world",children:"Step 2: Create a Launch File for the World"}),"\n",(0,s.jsx)(n.p,{children:"Now, create a launch file to start Gazebo with your custom world."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File"}),": ",(0,s.jsx)(n.code,{children:"humanoid_description/launch/gazebo_world.launch.py"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\n\ndef generate_launch_description():\n    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')\n    pkg_humanoid_description = get_package_share_directory('humanoid_description')\n\n    # Start Gazebo server and client\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(pkg_gazebo_ros, 'launch', 'gazebo.launch.py')\n        ),\n        launch_arguments={'world': os.path.join(\n            pkg_humanoid_description, 'worlds', 'obstacle_course.world'\n        )}.items()\n    )\n\n    return LaunchDescription([\n        gazebo\n    ])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-build-and-launch",children:"Step 3: Build and Launch"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# In ros2_ws\ncolcon build --packages-select humanoid_description\n\n# In a new terminal\nsource install/setup.bash\nros2 launch humanoid_description gazebo_world.launch.py\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should see Gazebo open, displaying your custom world with a box and a cylinder."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lab-2-spawning-your-humanoid-in-gazebo",children:"Lab 2: Spawning Your Humanoid in Gazebo"}),"\n",(0,s.jsx)(n.p,{children:"Now let's add the leg robot we defined in the previous chapter into our world."}),"\n",(0,s.jsx)(n.h3,{id:"step-1-add-a-gazebo-plugin-to-your-urdf",children:"Step 1: Add a Gazebo Plugin to your URDF"}),"\n",(0,s.jsxs)(n.p,{children:["To control the joints in Gazebo, we need the ",(0,s.jsx)(n.code,{children:"gazebo_ros2_control"})," plugin. This plugin reads joint commands from ROS 2 and applies forces in the simulation. Add this to your ",(0,s.jsx)(n.code,{children:"leg.urdf.xacro"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File"}),": ",(0,s.jsx)(n.code,{children:"humanoid_description/urdf/leg.urdf.xacro"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- ... at the end of the file, inside the <robot> tag ... --\x3e\n  <gazebo>\n    <plugin name="gazebo_ros2_control" filename="libgazebo_ros2_control.so">\n      <robot_param>robot_description</robot_param>\n      <robot_param_node>robot_state_publisher</robot_param_node>\n    </plugin>\n  </gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-a-launch-file-to-spawn-the-robot",children:"Step 2: Create a Launch File to Spawn the Robot"}),"\n",(0,s.jsxs)(n.p,{children:["This launch file will start the world, process your URDF, and then call the ",(0,s.jsx)(n.code,{children:"spawn_entity.py"})," script to add the robot to the simulation."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File"}),": ",(0,s.jsx)(n.code,{children:"humanoid_description/launch/spawn_leg.launch.py"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nimport xacro\n\ndef generate_launch_description():\n    pkg_humanoid_description = get_package_share_directory('humanoid_description')\n    \n    # Process the URDF file\n    xacro_file = os.path.join(pkg_humanoid_description, 'urdf', 'leg.urdf.xacro')\n    robot_description_raw = xacro.process_file(xacro_file).toxml()\n\n    # Gazebo launch\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([os.path.join(\n            get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']),\n        launch_arguments={'world': os.path.join(\n            pkg_humanoid_description, 'worlds', 'obstacle_course.world'\n        )}.items()\n    )\n\n    # Robot state publisher\n    node_robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        output='screen',\n        parameters=[{'robot_description': robot_description_raw}]\n    )\n\n    # Spawn entity\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=['-topic', 'robot_description', '-entity', 'simple_leg'],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo,\n        node_robot_state_publisher,\n        spawn_entity\n    ])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-build-and-launch-1",children:"Step 3: Build and Launch"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# In ros2_ws\ncolcon build --packages-select humanoid_description\n\n# In a new terminal\nsource install/setup.bash\nros2 launch humanoid_description spawn_leg.launch.py\n"})}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Image: Our humanoid leg model spawned and interacting with the physics simulation in Gazebo."}),"\n",(0,s.jsx)(n.em,{children:"A screenshot showing the simple leg robot spawned in the obstacle course world."})]})}),"\n",(0,s.jsx)(n.p,{children:"You should now see your leg robot appear in the Gazebo world. Because it has mass and is subject to gravity, it will immediately fall to the ground plane. Congratulations, you have a working physics simulation!"}),"\n",(0,s.jsx)(n.h2,{id:"common-errors-and-debugging",children:"Common Errors and Debugging"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error"}),': Robot model appears in Gazebo but is completely transparent or "ghostly."']}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cause"}),": The link has a ",(0,s.jsx)(n.code,{children:"<visual>"})," tag but no ",(0,s.jsx)(n.code,{children:"<collision>"})," tag. Gazebo's physics engine doesn't know its physical shape."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix"}),": Add a ",(0,s.jsx)(n.code,{children:"<collision>"})," tag to every link that should interact with the world. It's good practice to always have both."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error"}),": Robot falls through the ground plane."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cause"}),": The ground plane or the robot's links are missing ",(0,s.jsx)(n.code,{children:"<collision>"})," tags."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix"}),': Ensure every model that should be "solid" has collision geometry defined. Check the Gazebo GUI under the ',(0,s.jsx)(n.code,{children:"View"})," menu and enable ",(0,s.jsx)(n.code,{children:"Collisions"})," to visualize the collision shapes."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error"}),": ",(0,s.jsx)(n.code,{children:"spawn_entity"})," fails with a timeout."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cause"}),": Gazebo is taking a long time to load, and the spawn script gives up waiting for the ",(0,s.jsx)(n.code,{children:"/spawn_entity"})," service."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix"}),": This is common with complex worlds. You can increase the timeout in the ",(0,s.jsx)(n.code,{children:"spawn_entity.py"})," script or, more simply, run the launch file a second time once Gazebo is already running."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"student-exercises",children:"Student Exercises"}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"Exercise 1: Make a Bouncy Ball"}),(0,s.jsxs)("div",{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Task"}),": Create a new world file. Add a single sphere model to it. Using SDF properties, make this sphere highly bouncy."]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution Steps"}),":"]}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a new ",(0,s.jsx)(n.code,{children:".world"})," file."]}),"\n",(0,s.jsxs)(n.li,{children:["Add a ",(0,s.jsx)(n.code,{children:'<model name="bouncy_ball">'})," with a sphere geometry for visual and collision."]}),"\n",(0,s.jsxs)(n.li,{children:["Inside the ",(0,s.jsx)(n.code,{children:"<collision>"})," tag, add a ",(0,s.jsx)(n.code,{children:"<surface>"})," block."]}),"\n",(0,s.jsxs)(n.li,{children:["Inside the ",(0,s.jsx)(n.code,{children:"<surface>"})," block, add ",(0,s.jsx)(n.code,{children:"<restitution_coefficient>0.9</restitution_coefficient>"})," and ",(0,s.jsx)(n.code,{children:"<bounce><threshold>0.01</threshold></bounce>"}),". A restitution coefficient close to 1.0 makes it very bouncy."]}),"\n",(0,s.jsx)(n.li,{children:"Launch Gazebo with your new world and watch the ball bounce when it hits the ground."}),"\n"]})]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"Exercise 2: Create a Domino Rally"}),(0,s.jsxs)("div",{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Task"}),": Create a world with a series of thin, tall boxes lined up like dominoes. Spawn a sphere and give it an initial velocity so that it rolls into the first domino and knocks the whole chain down."]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution Steps"}),":"]}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a world file with 5-10 tall, thin ",(0,s.jsx)(n.code,{children:"<model>"}),"s representing dominoes, positioned close to each other."]}),"\n",(0,s.jsx)(n.li,{children:"Create another model for a sphere."}),"\n",(0,s.jsxs)(n.li,{children:["To give the sphere an initial velocity, you can write a small ROS 2 node that waits for the simulation to start and then publishes a single message to the ",(0,s.jsx)(n.code,{children:"/model/sphere/odometry"})," topic or uses a Gazebo plugin. A simpler way is to apply a force using the Gazebo GUI (Right-click the model -> Apply Force/Torque)."]}),"\n",(0,s.jsxs)(n.li,{children:["Alternatively, you can set an initial velocity directly in the world SDF for the ball link: ",(0,s.jsx)(n.code,{children:"<velocity>1 0 0 0 0 0</velocity>"}),"."]}),"\n"]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Official Documentation"}),": ",(0,s.jsx)(n.a,{href:"https://gazebosim.org/docs",children:"https://gazebosim.org/docs"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SDF Specification"}),": ",(0,s.jsx)(n.a,{href:"http://sdformat.org/spec",children:"http://sdformat.org/spec"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"gazebo_ros_pkgs"})," Documentation"]}),": ",(0,s.jsx)(n.a,{href:"http://wiki.ros.org/gazebo_ros_pkgs",children:"http://wiki.ros.org/gazebo_ros_pkgs"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Tutorials"}),": ",(0,s.jsx)(n.a,{href:"https://classic.gazebosim.org/tutorials",children:"https://classic.gazebosim.org/tutorials"})]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/docs/module-1/urdf-for-humanoids",children:(0,s.jsx)(n.strong,{children:"\u2190 Previous: URDF for Humanoids"})})," | ",(0,s.jsx)(n.a,{href:"/docs/module-2/high-fidelity-rendering-in-unity",children:(0,s.jsx)(n.strong,{children:"Next: High-Fidelity Rendering in Unity \u2192"})})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var o=i(6540);const s={},r=o.createContext(s);function t(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);