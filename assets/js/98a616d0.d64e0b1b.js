"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[5188],{8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var r=i(6540);const o={},t=r.createContext(o);function a(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),r.createElement(t.Provider,{value:e},n.children)}},8605:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1/urdf-for-humanoids","title":"Understanding URDF for Humanoid Robots: Anatomy of a Digital Body","description":"Introduction to the Unified Robot Description Format","source":"@site/docs/module-1/urdf-for-humanoids.md","sourceDirName":"module-1","slug":"/module-1/urdf-for-humanoids","permalink":"/docs/module-1/urdf-for-humanoids","draft":false,"unlisted":false,"editUrl":"https://github.com/SyedAbdulSami1/Physical-AI-Humanoid-Robotics-Textbook/tree/main/docs/module-1/urdf-for-humanoids.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Bridging Python Agents to ROS 2 Controllers with rclpy","permalink":"/docs/module-1/bridging-python-agents-to-ros2"},"next":{"title":"Module 2: The Digital Twin (Gazebo & Unity)","permalink":"/docs/category/module-2-the-digital-twin-gazebo--unity"}}');var o=i(4848),t=i(8453);const a={},l="Understanding URDF for Humanoid Robots: Anatomy of a Digital Body",s={},c=[{value:"Introduction to the Unified Robot Description Format",id:"introduction-to-the-unified-robot-description-format",level:2},{value:"Core Components of URDF",id:"core-components-of-urdf",level:2},{value:"Building a Simple Humanoid Leg Segment URDF",id:"building-a-simple-humanoid-leg-segment-urdf",level:2},{value:"Humanoid-Specific URDF Considerations",id:"humanoid-specific-urdf-considerations",level:2},{value:"Advanced URDF with Xacro",id:"advanced-urdf-with-xacro",level:2},{value:"Python Interaction with URDF (Parsing and Visualization)",id:"python-interaction-with-urdf-parsing-and-visualization",level:2},{value:"Lab 3.4: Dynamic URDF Generation with Python and Xacro",id:"lab-34-dynamic-urdf-generation-with-python-and-xacro",level:2},{value:"Common Pitfalls and Fixes in URDF for Humanoids",id:"common-pitfalls-and-fixes-in-urdf-for-humanoids",level:2},{value:"Student Exercises (with Hidden Solutions)",id:"student-exercises-with-hidden-solutions",level:2},{value:"Further Reading and Official Resources",id:"further-reading-and-official-resources",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components},{Details:i}=e;return i||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"understanding-urdf-for-humanoid-robots-anatomy-of-a-digital-body",children:"Understanding URDF for Humanoid Robots: Anatomy of a Digital Body"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-the-unified-robot-description-format",children:"Introduction to the Unified Robot Description Format"}),"\n",(0,o.jsx)(e.p,{children:"The Unified Robot Description Format (URDF) is an XML-based file format used in ROS 2 (and its predecessor ROS 1) to describe all the physical and kinematic properties of a robot. For humanoid robots, URDF is not merely a descriptive tool; it is the fundamental blueprint that defines their digital anatomy, dictating how they are simulated, controlled, and perceived within the robotic ecosystem. It captures everything from the physical segments (links) of the robot's body to the connections (joints) that allow movement, including sensory elements, visual meshes, and collision properties."}),"\n",(0,o.jsx)(e.p,{children:"In the context of Physical AI, a precise URDF model is indispensable. It serves as the single source of truth for inverse kinematics calculations (how to move joints to reach a target pose), dynamic simulations (how the robot moves under gravity and forces), collision detection (preventing the robot from self-colliding or hitting objects), and visualization (displaying the robot accurately in tools like RViz or Gazebo). Without a robust and accurate URDF, intelligent control algorithms developed in Python or other languages would lack the foundational understanding of the robot's physical structure, leading to erroneous behavior and potentially dangerous interactions in the real world."}),"\n",(0,o.jsx)(e.h2,{id:"core-components-of-urdf",children:"Core Components of URDF"}),"\n",(0,o.jsx)(e.p,{children:"A URDF file primarily consists of two main elements:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.code,{children:"<link>"})}),": Represents a rigid body segment of the robot. This could be a torso, a leg, an arm, a head, or even a sensor housing. Links have associated inertial properties (mass, inertia matrix), visual properties (geometry, color, mesh files), and collision properties (geometry for collision checking)."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.code,{children:"<joint>"})}),": Describes how two links are connected and the type of motion allowed between them. Joints define the robot's degrees of freedom (DOF). Common joint types include:","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"revolute"}),": A single rotational degree of freedom around an axis, with limits."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"continuous"}),": A revolute joint without limits (e.g., a wheel)."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"prismatic"}),": A single translational degree of freedom along an axis, with limits."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"fixed"}),": No motion allowed; rigidly connects two links."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"planar"}),": Two translational and one rotational DOF (in a plane)."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"floating"}),": All six DOFs (three translational, three rotational), typically used for the base link of a mobile robot or the root of a humanoid model in a floating base configuration."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["Each joint connects a ",(0,o.jsx)(e.code,{children:"parent"})," link to a ",(0,o.jsx)(e.code,{children:"child"})," link."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[Base Link (e.g., Torso)] --\x3e J1(Joint 1: Waist)\nJ1 --\x3e L1[Link 1: Lower Body]\nL1 --\x3e J2(Joint 2: Hip L)\nJ2 --\x3e L2[Link 2: Upper Leg L]\nL2 --\x3e J3(Joint 3: Knee L)\nJ3 --\x3e L3[Link 3: Lower Leg L]\nL3 --\x3e J4(Joint 4: Ankle L)\nJ4 --\x3e L4[Link 4: Foot L]\n\nJ1 --\x3e J5(Joint 5: Hip R)\nJ5 --\x3e L5[Link 5: Upper Leg R]\nL5 --\x3e J6(Joint 6: Knee R)\nJ6 --\x3e L6[Link 6: Lower Leg R]\nL6 --\x3e J7(Joint 7: Ankle R)\nJ7 --\x3e L7[Link 7: Foot R]\n\nA --\x3e J8(Joint 8: Shoulder L)\nJ8 --\x3e L8[Link 8: Upper Arm L]\nL8 --\x3e J9(Joint 9: Elbow L)\nJ9 --\x3e L9[Link 9: Forearm L]\nL9 --\x3e J10(Joint 10: Wrist L)\nJ10 --\x3e L10[Link 10: Hand L]\n\nJ8 --\x3e J11(Joint 11: Shoulder R)\nJ11 --\x3e L11[Link 11: Upper Arm R]\nL11 --\x3e J12(Joint 12: Elbow R)\nJ12 --\x3e L12[Link 12: Forearm R]\nL12 --\x3e J13(Joint 13: Wrist R)\nJ13 --\x3e L13[Link 13: Hand R]\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.em,{children:"Figure 3.1: Simplified kinematic chain for a humanoid robot, illustrating links and joints."})}),"\n",(0,o.jsx)(e.h2,{id:"building-a-simple-humanoid-leg-segment-urdf",children:"Building a Simple Humanoid Leg Segment URDF"}),"\n",(0,o.jsx)(e.p,{children:"Let's construct a basic URDF for a single leg segment of a humanoid robot. This will introduce the fundamental XML structure."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Lab 3.1: Creating a Basic Leg Segment URDF"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Goal"}),": Define a URDF for a single upper leg link connected by a revolute hip joint to a fixed base."]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Create a new ROS 2 package"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_cmake my_humanoid_description --dependencies rclpy urdf_tutorial\ncd my_humanoid_description\nmkdir urdf rviz\n"})}),"\n","(Note: ",(0,o.jsx)(e.code,{children:"ament_cmake"})," is generally preferred for URDF packages to utilize ",(0,o.jsx)(e.code,{children:"install"})," targets for meshes, etc.)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Create ",(0,o.jsx)(e.code,{children:"single_leg.urdf"})," in the ",(0,o.jsx)(e.code,{children:"urdf"})," directory"]}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid_leg">\n\n  \x3c!-- Base Link (Root of the leg chain) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n      <material name="grey">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Hip Joint --\x3e\n  <joint name="hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="upper_leg_link"/>\n    <origin xyz="0 0 -0.05" rpy="0 0 0"/> \x3c!-- Offset from base_link to connect to top of upper_leg_link --\x3e\n    <axis xyz="1 0 0"/> \x3c!-- Rotation around X-axis --\x3e\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="1.0"/>\n  </joint>\n\n  \x3c!-- Upper Leg Link --\x3e\n  <link name="upper_leg_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/> \x3c!-- Center of cylinder at origin, so move down by half length --\x3e\n      <material name="blue">\n        <color rgba="0.0 0.0 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Material definitions (good practice to centralize) --\x3e\n  <material name="grey">\n    <color rgba="0.7 0.7 0.7 1.0"/>\n  </material>\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n\n</robot>\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Create a launch file to display the URDF in RViz"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/my_humanoid_description/launch\n"})}),"\n","Create ",(0,o.jsx)(e.code,{children:"display_single_leg.launch.py"})," in ",(0,o.jsx)(e.code,{children:"launch"})," directory:","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.substitutions import Command, FindExecutable, PathJoinSubstitution\nfrom launch_ros.parameter_descriptors import ParameterValue\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    robot_description_content = ParameterValue(\n        Command([\n            PathJoinSubstitution([FindExecutable(name="xacro")]) , " ",\n            PathJoinSubstitution([\n                FindPackageShare("my_humanoid_description"), "urdf", "single_leg.urdf"\n            ])\n        ]),\n        value_type=str\n    )\n\n    robot_state_publisher_node = Node(\n        package="robot_state_publisher",\n        executable="robot_state_publisher",\n        parameters=[{"robot_description": robot_description_content}],\n        output="screen"\n    )\n\n    joint_state_publisher_gui_node = Node(\n        package="joint_state_publisher_gui",\n        executable="joint_state_publisher_gui",\n        output="screen"\n    )\n\n    rviz_node = Node(\n        package="rviz2",\n        executable="rviz2",\n        name="rviz2",\n        output="screen",\n        arguments=["-d", PathJoinSubstitution([FindPackageShare("urdf_tutorial"), "rviz", "urdf.rviz"])],\n        # If urdf_tutorial is not available, you can create a simple rviz config or run rviz2 without -d\n        # and manually add RobotModel and JointState components.\n    )\n\n    return LaunchDescription([\n        robot_state_publisher_node,\n        joint_state_publisher_gui_node,\n        rviz_node\n    ])\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Update ",(0,o.jsx)(e.code,{children:"package.xml"})]}),":\nAdd ",(0,o.jsx)(e.code,{children:"robot_state_publisher"}),", ",(0,o.jsx)(e.code,{children:"joint_state_publisher_gui"}),", ",(0,o.jsx)(e.code,{children:"rviz2"}),", ",(0,o.jsx)(e.code,{children:"xacro"}),", ",(0,o.jsx)(e.code,{children:"urdf_tutorial"})," (if using its rviz config) as dependencies.","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:"<depend>rclpy</depend>\n<depend>robot_state_publisher</depend>\n<depend>joint_state_publisher_gui</depend>\n<depend>rviz2</depend>\n<depend>xacro</depend>\n<depend>urdf_tutorial</depend> \x3c!-- Only if using its rviz config --\x3e\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Build and Source"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Launch the display"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"ros2 launch my_humanoid_description display_single_leg.launch.py\n"})}),"\n","You should see the base link and upper leg link in RViz, with a GUI to control the hip joint."]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Common Pitfall"}),": Incorrect ",(0,o.jsx)(e.code,{children:"origin"})," values in ",(0,o.jsx)(e.code,{children:"<joint>"})," tags lead to links being positioned incorrectly or disjointedly.\n",(0,o.jsx)(e.strong,{children:"Fix"}),": Carefully visualize the coordinate frames and ensure ",(0,o.jsx)(e.code,{children:"xyz"})," and ",(0,o.jsx)(e.code,{children:"rpy"})," values correctly transform from the parent's frame to the child's frame. Use ",(0,o.jsx)(e.code,{children:"rviz"})," to debug link placements."]}),"\n",(0,o.jsx)(e.h2,{id:"humanoid-specific-urdf-considerations",children:"Humanoid-Specific URDF Considerations"}),"\n",(0,o.jsxs)(e.p,{children:["While the basic ",(0,o.jsx)(e.code,{children:"<link>"})," and ",(0,o.jsx)(e.code,{children:"<joint>"})," elements are universal, designing URDFs for humanoid robots presents unique challenges:"]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"High Degrees of Freedom (DOF)"}),": Humanoids typically have 30+ DOFs, requiring careful organization and naming conventions."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Kinematic Chains"}),": Multiple complex kinematic chains for arms, legs, and torso."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance and Stability"}),": Inertial properties (mass, center of mass, inertia matrix) are critical for dynamic walking and balance control. An accurate URDF is the foundation for whole-body control."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Self-Collision"}),": Humanoid limbs can easily collide with each other. Collision meshes need to be defined precisely to prevent self-intersections."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensors"}),": Integrating cameras, LiDAR, IMUs, force/torque sensors, and other perception components directly into the URDF."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"advanced-urdf-with-xacro",children:"Advanced URDF with Xacro"}),"\n",(0,o.jsxs)(e.p,{children:["Writing complex URDF files directly in XML can become repetitive and error-prone. ",(0,o.jsx)(e.strong,{children:"Xacro"})," (XML Macros) is a powerful tool that allows for modularity, parameterization, and simplification of URDF files. It uses macro definitions and property assignments to generate the final URDF XML."]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Lab 3.2: Parameterizing a Joint with Xacro"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Goal"}),": Convert the ",(0,o.jsx)(e.code,{children:"single_leg.urdf"})," to ",(0,o.jsx)(e.code,{children:"single_leg.urdf.xacro"})," and parameterize the hip joint limits."]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Rename ",(0,o.jsx)(e.code,{children:"single_leg.urdf"})," to ",(0,o.jsx)(e.code,{children:"single_leg.urdf.xacro"})]}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"mv ~/ros2_ws/src/my_humanoid_description/urdf/single_leg.urdf ~/ros2_ws/src/my_humanoid_description/urdf/single_leg.urdf.xacro\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Edit ",(0,o.jsx)(e.code,{children:"single_leg.urdf.xacro"})]}),":\nAdd the xacro namespace and properties, and use them in the joint definition.","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid_leg" xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  \x3c!-- Xacro Properties --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n  <xacro:property name="hip_limit_lower" value="${-M_PI/2}" /> \x3c!-- -90 degrees --\x3e\n  <xacro:property name="hip_limit_upper" value="${M_PI/2}" />  \x3c!-- 90 degrees --\x3e\n  <xacro:property name="hip_effort" value="10.0" />\n  <xacro:property name="hip_velocity" value="1.0" />\n\n  \x3c!-- Base Link (Root of the leg chain) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n      <material name="grey">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Hip Joint --\x3e\n  <joint name="hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="upper_leg_link"/>\n    <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${hip_limit_lower}" upper="${hip_limit_upper}" effort="${hip_effort}" velocity="${hip_velocity}"/>\n  </joint>\n\n  \x3c!-- Upper Leg Link --\x3e\n  <link name="upper_leg_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <material name="blue">\n        <color rgba="0.0 0.0 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Material definitions --\x3e\n  <material name="grey">\n    <color rgba="0.7 0.7 0.7 1.0"/>\n  </material>\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n\n</robot>\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Update ",(0,o.jsx)(e.code,{children:"display_single_leg.launch.py"})]}),":\nChange the ",(0,o.jsx)(e.code,{children:"PathJoinSubstitution"})," for the URDF file to point to ",(0,o.jsx)(e.code,{children:".urdf.xacro"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.substitutions import Command, FindExecutable, PathJoinSubstitution\nfrom launch_ros.parameter_descriptors import ParameterValue\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    robot_description_content = ParameterValue(\n        Command([\n            PathJoinSubstitution([FindExecutable(name="xacro")]) , " ",\n            PathJoinSubstitution([\n                FindPackageShare("my_humanoid_description"), "urdf", "single_leg.urdf.xacro"\n            ])\n        ]),\n        value_type=str\n    )\n\n    robot_state_publisher_node = Node(\n        package="robot_state_publisher",\n        executable="robot_state_publisher",\n        parameters=[{"robot_description": robot_description_content}],\n        output="screen"\n    )\n\n    joint_state_publisher_gui_node = Node(\n        package="joint_state_publisher_gui",\n        executable="joint_state_publisher_gui",\n        output="screen"\n    )\n\n    rviz_node = Node(\n        package="rviz2",\n        executable="rviz2",\n        name="rviz2",\n        output="screen",\n        arguments=["-d", PathJoinSubstitution([FindPackageShare("urdf_tutorial"), "rviz", "urdf.rviz"])],\n    )\n\n    return LaunchDescription([\n        robot_state_publisher_node,\n        joint_state_publisher_gui_node,\n        rviz_node\n    ])\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Build and Source"}),", then ",(0,o.jsx)(e.strong,{children:"Launch the display"}),":\nThe result in RViz should be identical, but the underlying URDF is now more maintainable."]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Common Pitfall"}),": Forgetting the ",(0,o.jsx)(e.code,{children:"xmlns:xacro"})," declaration or incorrect syntax for property usage (",(0,o.jsx)(e.code,{children:"$ {property_name}"}),").\n",(0,o.jsx)(e.strong,{children:"Fix"}),": Double-check Xacro syntax. Use ",(0,o.jsx)(e.code,{children:"ros2 run xacro xacro single_leg.urdf.xacro"})," to expand the Xacro file into a plain URDF to check for errors."]}),"\n",(0,o.jsx)(e.h2,{id:"python-interaction-with-urdf-parsing-and-visualization",children:"Python Interaction with URDF (Parsing and Visualization)"}),"\n",(0,o.jsx)(e.p,{children:"While URDF is XML, Python tools allow for programmatic interaction, which is invaluable for dynamic robot configuration or analysis."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Lab 3.3: Parsing URDF with Python"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Goal"}),": Write a Python script to parse a URDF file and extract information about its links and joints."]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Create a Python script ",(0,o.jsx)(e.code,{children:"parse_urdf.py"})," in ",(0,o.jsx)(e.code,{children:"my_humanoid_description/scripts"})]}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/my_humanoid_description/scripts\ntouch ~/ros2_ws/src/my_humanoid_description/scripts/parse_urdf.py\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import os\nimport xml.etree.ElementTree as ET\nfrom ament_index_python.packages import get_package_share_directory\n\ndef parse_urdf(package_name, urdf_filename):\n    try:\n        # Get path to the package share directory\n        package_share_directory = get_package_share_directory(package_name)\n        urdf_path = os.path.join(package_share_directory, 'urdf', urdf_filename)\n\n        if not os.path.exists(urdf_path):\n            print(f\"Error: URDF file not found at {urdf_path}\")\n            return\n\n        print(f\"Parsing URDF from: {urdf_path}\")\n        tree = ET.parse(urdf_path)\n        root = tree.getroot()\n\n        print(f\"Robot Name: {root.attrib.get('name', 'Unnamed Robot')}\\n\")\n\n        print(\"--- Links ---\")\n        for link in root.findall('link'):\n            name = link.attrib.get('name')\n            inertial = link.find('inertial')\n            mass = inertial.find('mass').attrib.get('value') if inertial and inertial.find('mass') else 'N/A'\n            print(f\"  Link Name: {name}, Mass: {mass} kg\")\n\n        print(\"\\n--- Joints ---\")\n        for joint in root.findall('joint'):\n            name = joint.attrib.get('name')\n            joint_type = joint.attrib.get('type')\n            parent = joint.find('parent').attrib.get('link') if joint.find('parent') else 'N/A'\n            child = joint.find('child').attrib.get('link') if joint.find('child') else 'N/A'\n            axis = joint.find('axis').attrib.get('xyz') if joint.find('axis') else 'N/A'\n            limit = joint.find('limit')\n            lower = limit.attrib.get('lower') if limit else 'N/A'\n            upper = limit.attrib.get('upper') if limit else 'N/A'\n\n            print(f\"  Joint Name: {name}, Type: {joint_type}\")\n            print(f\"    Parent: {parent}, Child: {child}, Axis: {axis}\")\n            print(f\"    Limits: Lower={lower}, Upper={upper}\")\n            print(\"-\" * 20)\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["if ",(0,o.jsx)(e.strong,{children:"name"})," == '",(0,o.jsx)(e.strong,{children:"main"}),"':"]}),"\n",(0,o.jsx)(e.h1,{id:"ensure-to-use-the-correct-package-name-and-urdf-filename",children:"Ensure to use the correct package name and URDF filename"}),"\n",(0,o.jsx)(e.p,{children:"parse_urdf('my_humanoid_description', 'single_leg.urdf.xacro')"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"2.  **Update `setup.py` (for ament_python package that uses this script)**:\nIf this script were part of a Python package, you'd add it to `entry_points`. For now, you can just run it as a standalone Python script.\n3.  **Build and Source**:\n```bash\ncd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"4",children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Run the script"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"python3 ~/ros2_ws/src/my_humanoid_description/scripts/parse_urdf.py\n"})}),"\n","This will output the parsed link and joint information to the console."]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Common Pitfall"}),": Incorrect path to the URDF file, especially when using ",(0,o.jsx)(e.code,{children:"get_package_share_directory"}),".\n",(0,o.jsx)(e.strong,{children:"Fix"}),": Verify the ",(0,o.jsx)(e.code,{children:"package_name"})," and ",(0,o.jsx)(e.code,{children:"urdf_filename"})," are correct and that the file actually exists at the constructed path."]}),"\n",(0,o.jsx)(e.h2,{id:"lab-34-dynamic-urdf-generation-with-python-and-xacro",children:"Lab 3.4: Dynamic URDF Generation with Python and Xacro"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Goal"}),": Use Python to dynamically generate a URDF based on configuration parameters, then visualize it. This is powerful for robots with modular components or configurable dimensions."]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Create ",(0,o.jsx)(e.code,{children:"dynamic_robot.xacro"})," in ",(0,o.jsx)(e.code,{children:"urdf"})," directory"]}),":\nThis xacro will take arguments and define a simple robotic arm with configurable length.","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="dynamic_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  <xacro:arg name="arm_length" default="0.3"/>\n  <xacro:property name="arm_length_val" value="$(arg arm_length)"/>\n\n  <link name="base_link">\n    <visual>\n      <geometry><box size="0.1 0.1 0.05"/></geometry>\n      <material name="grey"><color rgba="0.7 0.7 0.7 1.0"/></material>\n    </visual>\n  </link>\n\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="arm_link"/>\n    <origin xyz="0 0 0.025" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-${M_PI/4}" upper="${M_PI/4}" effort="100.0" velocity="1.0"/>\n  </joint>\n\n  <link name="arm_link">\n    <visual>\n      <geometry><cylinder radius="0.02" length="${arm_length_val}"/></geometry>\n      <origin xyz="0 0 ${arm_length_val/2}" rpy="0 0 0"/>\n      <material name="blue"><color rgba="0.0 0.0 0.8 1.0"/></material>\n    </visual>\n  </link>\n\n  <material name="grey"><color rgba="0.7 0.7 0.7 1.0"/></material>\n  <material name="blue"><color rgba="0.0 0.0 0.8 1.0"/></material>\n\n</robot>\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Create a Python launch file ",(0,o.jsx)(e.code,{children:"display_dynamic_robot.launch.py"})," in ",(0,o.jsx)(e.code,{children:"launch"})," directory"]}),":\nThis launch file will pass arguments to the xacro.","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.substitutions import Command, FindExecutable, PathJoinSubstitution, TextSubstitution\nfrom launch_ros.parameter_descriptors import ParameterValue\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.conditions import IfCondition\nfrom launch.substitutions import LaunchConfiguration\n\ndef generate_launch_description():\n    declared_arguments = []\n    declared_arguments.append(\n        DeclareLaunchArgument(\n            "arm_length",\n            default_value="0.5", # Default arm length\n            description="Length of the robot arm in meters.",\n        )\n    )\n    declared_arguments.append(\n        DeclareLaunchArgument(\n            "use_rviz",\n            default_value="true",\n            description="Whether to start RViz2.",\n        )\n    )\n\n    arm_length = LaunchConfiguration("arm_length")\n    use_rviz = LaunchConfiguration("use_rviz")\n\n    robot_description_content = ParameterValue(\n        Command([\n            PathJoinSubstitution([FindExecutable(name="xacro")]) , " ",\n            PathJoinSubstitution([\n                FindPackageShare("my_humanoid_description"), "urdf", "dynamic_robot.xacro"\n            ]),\n            " arm_length:=", arm_length, # Pass argument to xacro\n        ]),\n        value_type=str\n    )\n\n    robot_state_publisher_node = Node(\n        package="robot_state_publisher",\n        executable="robot_state_publisher",\n        parameters=[{"robot_description": robot_description_content}],\n        output="screen"\n    )\n\n    joint_state_publisher_gui_node = Node(\n        package="joint_state_publisher_gui",\n        executable="joint_state_publisher_gui",\n        output="screen"\n    )\n\n    rviz_node = Node(\n        package="rviz2",\n        executable="rviz2",\n        name="rviz2",\n        output="screen",\n        arguments=["-d", PathJoinSubstitution([FindPackageShare("urdf_tutorial"), "rviz", "urdf.rviz"])],\n        condition=IfCondition(use_rviz)\n    )\n\n    return LaunchDescription(declared_arguments + [\n        robot_state_publisher_node,\n        joint_state_publisher_gui_node,\n        rviz_node\n    ])\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Build and Source"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Launch with different arm lengths"}),":","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"ros2 launch my_humanoid_description display_dynamic_robot.launch.py arm_length:=0.2\nros2 launch my_humanoid_description display_dynamic_robot.launch.py arm_length:=0.8\n"})}),"\n","Observe how the robot arm's length changes in RViz."]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Common Pitfall"}),": Incorrectly passing arguments to xacro or misinterpreting units (meters vs. other).\n",(0,o.jsx)(e.strong,{children:"Fix"}),": Verify ",(0,o.jsx)(e.code,{children:"xacro"})," command line syntax. Always define and use consistent units."]}),"\n",(0,o.jsx)(e.h2,{id:"common-pitfalls-and-fixes-in-urdf-for-humanoids",children:"Common Pitfalls and Fixes in URDF for Humanoids"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Mass and Inertia"}),": Incorrect values lead to unrealistic simulation behavior and unstable control.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fix"}),": Use CAD tools to calculate accurate inertial properties. For simple shapes, use standard formulas."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Collision Geometries"}),": Using complex visual meshes for collision can be computationally expensive and unstable. Not defining collisions leads to robots passing through objects.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fix"}),": Simplify collision geometries (boxes, cylinders, spheres) to approximate the visual mesh. Ensure collision models cover the robot's physical extent."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Joint Limits"}),": Missing or incorrect joint limits can lead to unnatural robot poses or self-collision.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fix"}),": Define realistic ",(0,o.jsx)(e.code,{children:"lower"})," and ",(0,o.jsx)(e.code,{children:"upper"})," limits for all revolute and prismatic joints, reflecting the physical constraints of the robot."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:[(0,o.jsx)(e.code,{children:"origin"})," and Coordinate Frames"]}),": A fundamental source of errors. Links might appear disconnected or misaligned.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fix"}),": Visualize coordinate frames in RViz. The ",(0,o.jsx)(e.code,{children:"origin"})," tag defines the pose of the child link's frame relative to the parent link's frame. Pay close attention to ",(0,o.jsx)(e.code,{children:"xyz"})," (translation) and ",(0,o.jsx)(e.code,{children:"rpy"})," (roll, pitch, yaw rotation) values."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Self-Collision (especially for humanoids)"}),": Due to high DOF and complex geometry, humanoids are prone to self-collision.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fix"}),": Define collision meshes carefully. Use ",(0,o.jsx)(e.code,{children:"<disable_collisions>"})," tags in URDF to explicitly ignore collisions between adjacent links that are always connected and should not collide (e.g., upper arm and forearm)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"student-exercises-with-hidden-solutions",children:"Student Exercises (with Hidden Solutions)"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Exercise 3.1: Add a Knee Joint"}),"\nExtend the ",(0,o.jsx)(e.code,{children:"single_leg.urdf.xacro"})," from Lab 3.2 to include a knee joint and a lower leg link. The knee joint should be a ",(0,o.jsx)(e.code,{children:"revolute"})," joint, rotating about the X-axis, with appropriate ",(0,o.jsx)(e.code,{children:"origin"})," and ",(0,o.jsx)(e.code,{children:"limit"})," values."]}),"\n",(0,o.jsxs)(i,{children:[(0,o.jsx)("summary",{children:"Solution (click to expand)"}),(0,o.jsxs)(e.p,{children:[(0,o.jsxs)(e.strong,{children:["Modified ",(0,o.jsx)(e.code,{children:"single_leg.urdf.xacro"})]}),":"]}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid_leg" xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  \x3c!-- Xacro Properties --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n  <xacro:property name="hip_limit_lower" value="${-M_PI/2}" />\n  <xacro:property name="hip_limit_upper" value="${M_PI/2}" />\n  <xacro:property name="hip_effort" value="10.0" />\n  <xacro:property name="hip_velocity" value="1.0" />\n\n  <xacro:property name="knee_limit_lower" value="0.0" />          \x3c!-- Can\'t bend backward --\x3e\n  <xacro:property name="knee_limit_upper" value="${M_PI/2}" />  \x3c!-- 90 degrees forward bend --\x3e\n  <xacro:property name="knee_effort" value="10.0" />\n  <xacro:property name="knee_velocity" value="1.0" />\n\n  \x3c!-- Base Link (Root of the leg chain) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n      <material name="grey">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Hip Joint --\x3e\n  <joint name="hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="upper_leg_link"/>\n    <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${hip_limit_lower}" upper="${hip_limit_upper}" effort="${hip_effort}" velocity="${hip_velocity}"/>\n  </joint>\n\n  \x3c!-- Upper Leg Link --\x3e\n  <link name="upper_leg_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <material name="blue">\n        <color rgba="0.0 0.0 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Knee Joint (new) --\x3e\n  <joint name="knee_joint" type="revolute">\n    <parent link="upper_leg_link"/>\n    <child link="lower_leg_link"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/> \x3c!-- Connects to the bottom of the upper leg link --\x3e\n    <axis xyz="1 0 0"/> \x3c!-- Rotation around X-axis --\x3e\n    <limit lower="${knee_limit_lower}" upper="${knee_limit_upper}" effort="${knee_effort}" velocity="${knee_velocity}"/>\n  </joint>\n\n  \x3c!-- Lower Leg Link (new) --\x3e\n  <link name="lower_leg_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/> \x3c!-- Center of cylinder at origin --\x3e\n      <material name="green">\n        <color rgba="0.0 0.8 0.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <inertia ixx="0.03" ixy="0.0" ixz="0.0" iyy="0.03" iyz="0.0" izz="0.005"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Material definitions --\x3e\n  <material name="grey">\n    <color rgba="0.7 0.7 0.7 1.0"/>\n  </material>\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n  <material name="green">\n    <color rgba="0.0 0.8 0.0 1.0"/>\n  </material>\n\n</robot>\n'})}),(0,o.jsx)(e.p,{children:"Remember to rebuild and relaunch the display."})]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Exercise 3.2: Sensor Integration"}),"\nAdd a simple camera sensor to the ",(0,o.jsx)(e.code,{children:"base_link"})," of the ",(0,o.jsx)(e.code,{children:"single_leg.urdf.xacro"})," (or the complete leg from Exercise 3.1). The camera should be a simple box visual element."]}),"\n",(0,o.jsxs)(i,{children:[(0,o.jsx)("summary",{children:"Solution (click to expand)"}),(0,o.jsxs)(e.p,{children:[(0,o.jsxs)(e.strong,{children:["Modified ",(0,o.jsx)(e.code,{children:"single_leg.urdf.xacro"})," (adding camera to ",(0,o.jsx)(e.code,{children:"base_link"}),")"]}),":"]}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid_leg" xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  \x3c!-- Xacro Properties --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n  <xacro:property name="hip_limit_lower" value="${-M_PI/2}" />\n  <xacro:property name="hip_limit_upper" value="${M_PI/2}" />\n  <xacro:property name="hip_effort" value="10.0" />\n  <xacro:property name="hip_velocity" value="1.0" />\n\n  <xacro:property name="knee_limit_lower" value="0.0" />\n  <xacro:property name="knee_limit_upper" value="${M_PI/2}" />\n  <xacro:property name="knee_effort" value="10.0" />\n  <xacro:property name="knee_velocity" value="1.0" />\n\n  \x3c!-- Base Link (Root of the leg chain) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n      <material name="grey">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Camera Joint (new) --\x3e\n  <joint name="camera_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="camera_link"/>\n    <origin xyz="0.05 0 0.025" rpy="0 0 0"/> \x3c!-- Mounted on top-front of base_link --\x3e\n  </joint>\n\n  \x3c!-- Camera Link (new) --\x3e\n  <link name="camera_link">\n    <visual>\n      <geometry>\n        <box size="0.03 0.03 0.03"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Hip Joint --\x3e\n  <joint name="hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="upper_leg_link"/>\n    <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${hip_limit_lower}" upper="${hip_limit_upper}" effort="${hip_effort}" velocity="${hip_velocity}"/>\n  </joint>\n\n  \x3c!-- Upper Leg Link --\x3e\n  <link name="upper_leg_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <material name="blue">\n        <color rgba="0.0 0.0 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Knee Joint --\x3e\n  <joint name="knee_joint" type="revolute">\n    <parent link="upper_leg_link"/>\n    <child link="lower_leg_link"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${knee_limit_lower}" upper="${knee_limit_upper}" effort="${knee_effort}" velocity="${knee_velocity}"/>\n  </joint>\n\n  \x3c!-- Lower Leg Link --\x3e\n  <link name="lower_leg_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <material name="green">\n        <color rgba="0.0 0.8 0.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <inertia ixx="0.03" ixy="0.0" ixz="0.0" iyy="0.03" iyz="0.0" izz="0.005"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Material definitions --\x3e\n  <material name="grey">\n    <color rgba="0.7 0.7 0.7 1.0"/>\n  </material>\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n  <material name="green">\n    <color rgba="0.0 0.8 0.0 1.0"/>\n  </material>\n  <material name="black">\n    <color rgba="0.1 0.1 0.1 1.0"/>\n  </material>\n\n</robot>\n'})}),(0,o.jsx)(e.p,{children:"Remember to rebuild and relaunch the display."})]}),"\n",(0,o.jsx)(e.h2,{id:"further-reading-and-official-resources",children:"Further Reading and Official Resources"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"URDF Documentation"}),": The definitive guide to the URDF format.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Main.html",children:"ROS 2 URDF Overview"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"http://wiki.ros.org/urdf/XML",children:"URDF XML Specification"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Xacro Documentation"}),": For writing modular and parameterized URDFs.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/Using-Xacro-to-Clean-Up-a-URDF-File.html",children:"ROS 2 Xacro Tutorial"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RViz2"}),": The primary visualization tool for ROS 2.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/Viewing-a-URDF-Model.html",children:"RViz2 User Guide"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gazebo"}),": For simulating the robot's physical interactions.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"http://classic.gazebosim.org/tutorials",children:"Gazebo Tutorials"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Understanding and effectively utilizing URDF is a critical skill for any roboticist, especially those working with complex humanoid platforms. It forms the digital foundation upon which all simulation, control, and interaction capabilities are built. With Xacro, this foundation becomes robust, flexible, and scalable, ready to accommodate the intricate designs of advanced Physical AI systems. The next module will delve into simulating these digital twins in high-fidelity environments."}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.a,{href:"/docs/module-1/bridging-python-agents-to-ros2",children:(0,o.jsx)(e.strong,{children:"\u2190 Previous: Bridging Python Agents to ROS 2"})})," | ",(0,o.jsx)(e.a,{href:"/docs/module-2/simulating-physics-in-gazebo",children:(0,o.jsx)(e.strong,{children:"Next: Module 2: The Digital Twin \u2192"})})]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);